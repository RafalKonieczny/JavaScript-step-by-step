<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        /*
        // Teoria undefined

        // undefined to identyfikator, jest to zarówno typ jak i wartość,
        // undefined ma tylko jedną wartość,
        // Automatycznie jest przypisana do nowo zadeklarowanej zmiennej,
        // która nie ma wartości

        let data;
        typeof data; // typ jest undefined

        // undefined jest również jako identyfikator cześcią globalnego obiektu:
        console.log(window.undefined);

        // undefined jest zwykle rozumiane jako brak wartości, że wartość 
        // nie została jeszcze powiązana z zmienną.
        
        // undefined
        // Nie wolno przesłaniać lokalnej wartości undefined! Natomiast jest to mozliwe.

        // Uwaga, nie mozna tak robić, jako ciekawostka
        // można utworzyć zmienną lokalną undefined i nadać jej wartość
        function test() {
            let undefined = 2;
            console.log("wartość:" + undefined);
        };

        test(); // wartość: 2

        // Operator typeof dla undefined zwraca string "undefined" ponieważ jest to prymityw.

        typeof undefined; // "undefined"


        // Zmienne niezadeklarowane vs niezdefiniowane
        // Zmienna niezdefiniowana to zmienna, która jest zadeklarowana, 
        // ale nie przechowuje wartości. Zmienna niezadeklarowana to zmienna, 
        // która nie jest zadeklarowana.

        >>  var a; //zmienna niezdefiniowana, nie przechowuje wartości
            a;  // undefined

            b;  // zmienna niezadeklarowana, zwraca bład ReferenceError
                // Uwaga: b is not defined nie opisuje prawidłowo tej sytuacji

        >> typeof b;    // zmienna niezadeklarowana w typof również pokazuje
                        // niestety undefined, byłoby lepiej jako undeclared,
                        // ale tak nie jest
        < "undefined" 
        
        // typeof zwracające undefined ma oczywiście sens, jest to specjalne 
        // zabezpieczenie aby kod nie skutkował błedem z niezadeklarowaną zmienną.
        // Niestety zwracany komunikat jest w pewien sposób niejasny.
        */

        // Przykłady undefined

        let a; // zmienna jest zadeklarowana
        console.log(a); // undefined, nie ma wartości w zmiennej
        if (a == undefined) console.log("Brak wartości");

        /*
        b; 
        bład:
        Uncaught ReferenceError: b is not defined
        // w praktyce zmienna jest niezadeklarowana bo nie ma użytego
        // let, const czy var
        */

        console.log(typeof b); // undefined

        /*
        // Teoria null
        // null oznacza wartość pusta, wcześniej mogła być przechowywana wartość,
        // ale już nie jest. W przeciwieństwie do undefined null jest słowem kluczowym,
        // a nie identyfikatorem.

        let data = 10; // przypisana wartośc 10
        data = null; // teraz data nie ma wartości, jest null

        // Operator typeof dla null zwraca string "object" mimo, że jest to prymityw.

        typeof null; // "object" - wyjatek zamiast zwrócic null

        // null i undefined to falsy values

        // przy konwersji null oraz undefined na typ boolean 
        //stają się wartością false.

        if (null) {
            console.log("nie wykona się");
        }

        if (undefined) {
            console.log("nie wykona się");
        }

        // Porównanie null i undefined

        // proste porównanie, tylko wartości, jesli nie są tego samego typu
        // to bedzie konwersja

        if (null == undefined ) console.log("true, wykona sie");

        // porównanie ścisłe, typy się nie zgadzają, więc nie równe
        
        if (null === undefined ) console.log("false, NIE wykona sie");
        */

        // Przykłady null

        // null - intencjonalne wskazanie że zmienna nie ma wartości
        let test = 5;
        console.log(test); // 5

        test = null;
        console.log(test); // null
        console.log(typeof null); // "object"

        // null i undefine to falsy values - fałszywe wartości
        if (null) console.log("nie wykona się bo null zamienione na false");
        if (undefined) console.log("nie wykona się bo undefined zamienione na false");

        // porównanie proste
        if (null == undefined ) console.log("true, wykona sie");

        // porównanie ścisłe
        // porównanie zarówno typu! mamy false bo dwa różne typy
        // jak i wartości
        if (null === undefined ) console.log("false, NIE wykona sie");

    </script>
</body>
</html>